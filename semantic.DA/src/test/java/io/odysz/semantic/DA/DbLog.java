//package io.odysz.semantic.DA;
//
//import java.sql.SQLException;
//import java.util.ArrayList;
//
//import org.xml.sax.SAXException;
//
//import io.odysz.semantic.DASemantext;
//import io.odysz.semantic.util.SQLString;
//import io.odysz.semantics.ISemantext;
//import io.odysz.semantics.SemanticObject;
//import io.odysz.semantics.x.SemanticException;
//import io.odysz.transact.x.TransException;
//
///**<pre>DB oracle: 
//CREATE TABLE GARZE.A_LOGS (
//	logId VARCHAR2(45),
//	oper VARCHAR2(45),
//	operDate DATE,
//	funcName VARCHAR2(45),
//	funcId VARCHAR2(45),
//	cmd varchar2(45),
//	url varchar2(1000),
//	txt CLOB,
//	cnt NUMBER(22,0),
//	CONSTRAINT PK_A_LOGS PRIMARY KEY (logId)
//) ;
//
// * DB Mysql:
//
//CREATE TABLE a_logs (
//	logId varchar(45),
//	oper varchar(45),
//	operDate datetime,
//	funcName varchar(45),
//	funcId varchar(45),
//	cmd varchar(45),
//	url varchar(1000),
//	cnt int,
//	txt longtext,
//	CONSTRAINT PK_A_LOGS PRIMARY KEY (logId)
//) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
//
// * DB sqlite
//
//CREATE TABLE a_logs (
//	logId TEXT(20),
//	logTime INTEGER,
//	oper TEXT(20),
//	funcId TEXT(20),
//	funcName TEXT(200),
//	txt TEXT
//);<pre>
// * dataset.xml/id = log-template/mysql<br>
// * insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, cnt, txt) values ('%s', '%s', '%s', '%s', %s, '%s', now(), '%s', '%s') <br>
// * <br>
// * dataset.xml/id = log-template/orcl<br>
// * insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, cnt, txt) values ('%s', '%s', '%s', '%s', %s, '%s', sysdate, '%s', '%s') <br>
// * 
// * use this class as log info object.<br>
// * Generated by updte.serv etc., handled by DaSrc when db update event happened.
// * @author ody
// *
// */
//public class DbLog {
//	private DATranscxt rawst;
//
//	private String uid;
//	private String funcName;
//	private String funcId;
//	
//	/**Stub only for dumb subclass. Don't use this if log() will be called 
//	 * @throws SAXException 
//	 * @throws SemanticException */
//	DbLog() throws SemanticException, SAXException {
//		ISemantext semt = new DASemantext(null);
//		rawst = new DATranscxt(semt); 
//	}
//
//	public DbLog(SemanticObject jheader) throws SQLException {
//		rawst = new DATranscxt(null); 
//		this.uid = jheader.getString("userId");
//		SemanticObject userAct = (SemanticObject) jheader.get("usrAct");
//		if (userAct == null)
//			throw new SQLException("Reqest payload header.usrAct is null. Log information can't initialized.");
//		this.funcName = userAct.getString("funcName");
//		this.funcId = userAct.getString("funcId");
//	}
//
//	public void log(ArrayList<String> sqls) {
//		// no exception can be thrown here, no error message for client if failed.
//		try {
//			// String newId = DASemantext.genId(Connects.defltConn(), "a_logs", "logId", null);
//			// String sql = DatasetCfg.getSqlx(Connects.defltConn(), "log-template",
//			//	// insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, txt)
//			//	// values ('%s', '%s', '%s', '%s', null, '%s', sysdate, '%s');
//			//	newId, uid, funcName, funcId, cmd, url, String.valueOf(sqls.size()), txt(sqls));
//			rawst.insert("a_logs", null)
//				.nv("oper", uid)
//				.nv("funcName", funcName)
//				.nv("funcId", funcId)
//				.nv("txt", txt(sqls))
//				.ins();
//			//Connects.commitLog(sql); // reporting commit failed in err console
//		} catch (SQLException e) {
//			// failed case must be a bug - commitLog()'s exception already caught.
//			e.printStackTrace();
//		} catch (TransException e) {
//			e.printStackTrace();
//		}
//	}
//	
////	public void log(ArrayList<String> sqls, AbsConnect driver) {
////		// no exception can be thrown here, no error response to client if failed.
////		try {
////			String newId = Connects.genId(Connects.defltConn(), "a_logs", "logId", null);
////			String sql = DatasetCfg.getSqlx(Connects.defltConn(), "log-template",
////				// insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, txt)
////				// values ('%s', '%s', '%s', '%s', null, '%s', sysdate, '%s');
////				newId, uid, funcName, funcId, cmd, url, String.valueOf(sqls.size()), txt(sqls));
////			Connects.commitLog(sql); // reporting commit failed in err console
////		} catch (SQLException e) {
////			// failed case must be a bug - commitLog()'s exception already caught.
////			e.printStackTrace();
////		}
////	}
//
//	public DbLog(String usr, String funcName, String funcId, String cmd) {
//		this.uid = usr;
//		this.funcName = funcName;
//		this.funcId = funcId;
//	}
//
////	public void log(ArrayList<String> sqls, String cmd) {
////		try {
////			this.cmd = cmd;
////			String newId = Dao.genId(Dao.getDefltConnId(), "a_logs", "logId", null);
////			String sql = DatasetCfg.getSqlx(Dao.getDefltConnId(), "log-template",
////				// insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, txt)
////				// values ('%s', '%s', '%s', '%s', null, '%s', sysdate, '%s');
////				newId, uid, funcName, funcId, cmd, url, String.valueOf(sqls.size()), txt(sqls));
////			Dao.commitLog(sql); // reporting commit failed in err console
////		} catch (SQLException e) {
////			// failed case must be a bug - commitLog()'s exception already caught.
////			e.printStackTrace();
////		}
////	}
//
//	/**Format log.txt field
//	 * @param sqls
//	 * @return
//	 */
//	private static String txt(ArrayList<String> sqls) {
//		String txt = "";
//		if (sqls != null && sqls.size() > 0) {
//			for (String sql : sqls)
//				txt += SQLString.formatSql(sql) + "; ";
//		}
//		return txt;
//	}
//
//	public static ArrayList<OracleLob> formatLob(String log) {
//		OracleLob lob = new OracleLob("a_logs", "txt", log);
//		ArrayList<OracleLob> lobs = new ArrayList<OracleLob>(1);
//		lobs.add(lob);
//		return lobs;
//	}
//
//}
