package io.odysz.semantic.DA;

import java.sql.SQLException;
import java.util.ArrayList;

import io.odysz.semantic.SUser;
import io.odysz.semantic.SemanticObject;
import io.odysz.semantic.DA.cp.CpDriver;
import io.odysz.semantic.util.SQLString;

/**Modifying History:
 * 1. Dao.commit()<br>
 * 2. This class<br>
 * 3. <pre>DB oracle: 
CREATE TABLE GARZE.A_LOGS (
	logId VARCHAR2(45),
	oper VARCHAR2(45),
	operDate DATE,
	funcName VARCHAR2(45),
	funcId VARCHAR2(45),
	cmd varchar2(45),
	url varchar2(1000),
	txt CLOB,
	cnt NUMBER(22,0),
	CONSTRAINT PK_A_LOGS PRIMARY KEY (logId)
) ;

 * DB Mysql:

CREATE TABLE a_logs (
	logId varchar(45),
	oper varchar(45),
	operDate datetime,
	funcName varchar(45),
	funcId varchar(45),
	cmd varchar(45),
	url varchar(1000),
	cnt int,
	txt longtext,
	CONSTRAINT PK_A_LOGS PRIMARY KEY (logId)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;
<pre>
 * 4.1<br>
 * dataset.xml/id = log-template/mysql<br>
 * insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, cnt, txt) values ('%s', '%s', '%s', '%s', %s, '%s', now(), '%s', '%s') <br>
 * 4.2<br>
 * dataset.xml/id = log-template/orcl<br>
 * insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, cnt, txt) values ('%s', '%s', '%s', '%s', %s, '%s', sysdate, '%s', '%s') <br>
 * 
 * use this class as log info object.<br>
 * Generated by updte.serv etc., handled by DaSrc when db update event happened.
 * @author ody
 *
 */
public class DbLog {
	private String uid;
	private String funcName;
	private String funcId;
	private String url;
	private String cmd;
	
	/**Stub only for dumb subclass. Don't use this if log() will be called */
	DbLog() { }

	public DbLog(SUser usr, SemanticObject jheader) throws SQLException {
		this.uid = usr.getLogId();
		SemanticObject userAct = jheader.get("usrAct");
		if (userAct == null)
			throw new SQLException("Reqest payload header.usrAct is null. Log information can't initialized.");
		this.funcName = userAct.getString("funcName");
		this.funcId = userAct.getString("funcId");
		this.url = userAct.getString("url");
		String cmd = userAct.getString("cmd");
		this.cmd = cmd == null || cmd.trim().length() == 0 ? "null" : String.format("'%s'", cmd.trim());
	}

//	public DbLog(SUser usr, SemanticObject jheader) throws SQLException {
//		this.uid = usr.getLogId();
//		JsonObject userAct = jheader.getJsonObject("usrAct");
//		if (userAct == null)
//			throw new SQLException("Reqest payload header.usrAct is null. Log information can't initialized.");
//		this.funcName = userAct.getString("funcName");
//		this.funcId = userAct.getString("funcId");
//		this.url = userAct.getString("url");
//		String cmd = userAct.getString("cmd");
//		this.cmd = cmd == null || cmd.trim().length() == 0 ? "null" : String.format("'%s'", cmd.trim());
//	}

	public void log(ArrayList<String> sqls) {
		// no exception can be thrown here, no error response to client if failed.
		try {
			String newId = Connects.genId(Connects.defltConn(), "a_logs", "logId", null);
			String sql = DatasetCfg.getSqlx(CpDriver.getDefltConnId(), "log-template",
				// insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, txt)
				// values ('%s', '%s', '%s', '%s', null, '%s', sysdate, '%s');
				newId, uid, funcName, funcId, cmd, url, String.valueOf(sqls.size()), txt(sqls));
			CpDriver.commitLog(sql); // reporting commit failed in err console
		} catch (SQLException e) {
			// failed case must be a bug - commitLog()'s exception already caught.
			e.printStackTrace();
		}
	}
	
	public void log(ArrayList<String> sqls, AbsConnect driver) {
		// no exception can be thrown here, no error response to client if failed.
		try {
			String newId = Connects.genId(Connects.defltConn(), "a_logs", "logId", null);
			String sql = DatasetCfg.getSqlx(CpDriver.getDefltConnId(), "log-template",
				// insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, txt)
				// values ('%s', '%s', '%s', '%s', null, '%s', sysdate, '%s');
				newId, uid, funcName, funcId, cmd, url, String.valueOf(sqls.size()), txt(sqls));
			CpDriver.commitLog(sql); // reporting commit failed in err console
		} catch (SQLException e) {
			// failed case must be a bug - commitLog()'s exception already caught.
			e.printStackTrace();
		}
	}

	public DbLog(SUser usr, String funcName, String funcId, String cmd) {
		this.uid = usr.getLogId();
		this.funcName = funcName;
		this.funcId = funcId;
		this.url = "";
		this.cmd = cmd == null || cmd.trim().length() == 0 ? "null" : String.format("'%s'", cmd.trim());
	}

//	public void log(ArrayList<String> sqls, String cmd) {
//		try {
//			this.cmd = cmd;
//			String newId = Dao.genId(Dao.getDefltConnId(), "a_logs", "logId", null);
//			String sql = DatasetCfg.getSqlx(Dao.getDefltConnId(), "log-template",
//				// insert into a_logs(logId, oper, funcName, funcId, cmd, url, operDate, txt)
//				// values ('%s', '%s', '%s', '%s', null, '%s', sysdate, '%s');
//				newId, uid, funcName, funcId, cmd, url, String.valueOf(sqls.size()), txt(sqls));
//			Dao.commitLog(sql); // reporting commit failed in err console
//		} catch (SQLException e) {
//			// failed case must be a bug - commitLog()'s exception already caught.
//			e.printStackTrace();
//		}
//	}

	/**Format log.txt field
	 * @param sqls
	 * @return
	 */
	private static String txt(ArrayList<String> sqls) {
		String txt = "";
		if (sqls != null && sqls.size() > 0) {
			for (String sql : sqls)
				txt += SQLString.formatSql(sql) + "; ";
		}
		return txt;
	}

	public static ArrayList<OracleLob> formatLob(String log) {
		OracleLob lob = new OracleLob("a_logs", "txt", log);
		ArrayList<OracleLob> lobs = new ArrayList<OracleLob>(1);
		lobs.add(lob);
		return lobs;
	}

}
